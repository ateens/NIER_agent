"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateParallelChartTool = void 0;
const zod_1 = require("zod");
const utils_1 = require("../utils/index.js");
const schema_1 = require("../utils/schema.js");
// Parallel chart data schema
const data = zod_1.z.object({
    name: zod_1.z.string().describe("Name or identifier for this data series."),
    values: zod_1.z.array(zod_1.z.number()).describe("Array of values for each dimension."),
});
exports.generateParallelChartTool = {
    name: "generate_parallel_chart",
    description: "Generate a parallel coordinates chart to display multi-dimensional data, such as, comparing different products across multiple attributes.",
    inputSchema: zod_1.z.object({
        data: zod_1.z
            .array(data)
            .describe("Data for parallel chart, such as, [{ name: 'Product A', values: [4.2, 3.4, 2.3, 1.8] }].")
            .nonempty({ message: "Parallel chart data cannot be empty." }),
        dimensions: zod_1.z
            .array(zod_1.z.string())
            .describe("Names of the dimensions/axes, such as, ['Price', 'Quality', 'Service', 'Value'].")
            .nonempty({ message: "At least one dimension is required." }),
        height: schema_1.HeightSchema,
        theme: schema_1.ThemeSchema,
        title: schema_1.TitleSchema,
        width: schema_1.WidthSchema,
        outputType: schema_1.OutputTypeSchema,
    }),
    run: (params) => __awaiter(void 0, void 0, void 0, function* () {
        const { data, dimensions, height, theme, title, width, outputType } = params;
        // Calculate min/max for each dimension
        const parallelAxis = dimensions.map((dim, index) => {
            const values = data
                .map((item) => item.values[index])
                .filter((v) => v !== undefined);
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min;
            return {
                dim: index,
                name: dim,
                min: min - range * 0.1,
                max: max + range * 0.1,
                nameLocation: "start",
            };
        });
        // Transform data for ECharts - create separate series for each data item
        const series = data.map((item) => ({
            name: item.name,
            type: "parallel",
            data: [
                {
                    name: item.name,
                    value: item.values,
                },
            ],
            lineStyle: {
                width: 2,
                opacity: 0.7,
            },
            emphasis: {
                lineStyle: {
                    width: 4,
                    opacity: 1,
                },
            },
            smooth: true,
        }));
        const echartsOption = {
            parallelAxis: parallelAxis,
            parallel: {
                left: "5%",
                right: "13%",
                bottom: "20%",
                top: "15%",
                parallelAxisDefault: {
                    type: "value",
                    nameLocation: "end",
                    nameGap: 20,
                    nameTextStyle: {
                        fontSize: 12,
                    },
                    axisLine: {
                        lineStyle: {
                            color: "#aaa",
                        },
                    },
                    axisTick: {
                        lineStyle: {
                            color: "#777",
                        },
                    },
                    splitLine: {
                        show: false,
                    },
                    axisLabel: {
                        color: "#999",
                    },
                },
            },
            series,
            title: {
                left: "center",
                text: title,
            },
            tooltip: {
                trigger: "item",
            },
            legend: {
                bottom: 30,
                data: data.map((item) => item.name),
            },
        };
        return yield (0, utils_1.generateChartImage)(echartsOption, width, height, theme, outputType, "generate_parallel_chart");
    }),
};
